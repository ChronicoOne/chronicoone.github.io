<!DOCTYPE html>

<html lang="en-US">

	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="game.css">
		<meta name="author" content="Connor Bowman"/>
		<link rel="icon" href="../img/gorbu_favicon.png" type="image/x-icon"/>
		<meta name="author" content="Connor Bowman"/>
		<meta name="description"
		      content="BoxJump is an endless platformer game created by Connor Bowman."/>
		<title>BoxJump | Chronico.One</title>	
	</head>
		
	</head>
	
	<body>
		
		
		<div id="TopBox" class="ui">
			<p class="ui-p">Health: <span  id="Health">0</span></p>
			<p class="ui-p">Score: <span id="Score">0</span></p>
		</div>
		
		<div id="BottomBox" class="ui">
			<p class="ui-p">High Score: <span id="HighScore">0</span></p>
		</div>
		
		<div id="Player"></div>
		<svg id="Arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8.13 100"><line x1="4.06" y1="50" x2="4.06" y2="44.5" style="fill:none;stroke:#000;stroke-miterlimit:10"/><line x1="4.06" y1="43.64" x2="4.06" y2="12.99" style="fill:none;stroke:#000;stroke-miterlimit:10;stroke-dasharray:9.495512008666992,0.8632283806800842"/><line x1="4.06" y1="12.56" x2="4.06" y2="7.06" style="fill:none;stroke:#000;stroke-miterlimit:10"/><polygon points="4.06 0 8.13 9.95 4.06 7.59 0 9.95 4.06 0"/><line x1="3.81" y1="100" x2="3.81" y2="50" style="fill:none"/></svg>
		<svg id="HeartCoin" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 91.42 86.9"><path d="M49.22,93.23,87.56,53.88C97.71,43.46,97.92,26.24,88,15.43h0a24.67,24.67,0,0,0-36.29-.71L13.42,54.07Z" transform="translate(-3.89 -6.93)" style="fill:red"/><path d="M48.51,93.83,11.17,53a28.34,28.34,0,0,1,.48-38.44h0a24.64,24.64,0,0,1,36.28.71L85.27,56.09Z" transform="translate(-3.89 -6.93)" style="fill:red"/></svg>


		
		<script>
		
		const refresh = 17;
		const G = 0.02;
		const player = document.getElementById('Player');
		const arrow = document.getElementById('Arrow');
		
		const fallingVerts = [];
		const fallingHearts = [];
		
		const scoreBox = document.getElementById('Score');
		const healthBox = document.getElementById('Health');
		const highScoreBox = document.getElementById('HighScore');
		
		let highScore = 0;
		
		let cookieValue = document.cookie.split('; ').find((row) => row.startsWith('highScore='))?.split('=')[1];
		
		if (typeof cookieValue === 'undefined') {
			document.cookie = 'highScore=0';
		} else {
			highScore = +(cookieValue);
		}
		
		console.log(cookieValue);
		
		let maxVerts = 5;
		let dropInterval = 10000;
		let health = 10;
		let posX = 0;
		let posY = 0;
		let velX = 0;
		let velY = 0;
		let launch = 50;
		let score = 0;
		let cursorX = 0;
		let cursorY = 0;
		let tilt = 0;
		let arrowHeight = 20;
		let arrowWidth = 20;
		let arrowOffsetY = 10;
		let arrowOffsetX = 10;
		let vertSpawnX = 50;
		let vertSpawnY = -10;
		
		let growing = false;
		let running = true;
		
		let vh = window.innerHeight;
		let vw = window.innerWidth;
		
		function restart(){
			maxVerts = 5;
			dropInterval = 10000;
			health = 10;
			posX = 0;
			posY = 0;
			velX = 0;
			velY = 0;
			launch = 50;
			score = 0;
			arrowHeight = 20;
			arrowWidth = 20;
			arrowOffsetY = 10;
			arrowOffsetX = 10;
			vertSpawnX = 50;
			vertSpawnY = -10;
		
			setTimeout( () => {running = true; }, refresh * 10)
		}
		
		function gravity() {
			velY += G;
			for (const vert of fallingVerts) {
				vert.velY += G;
			}
		}
		
		function updatePlayerPos() {
			posX += velX;
			posY += velY;
		}
			
		function growArrow() {
			if(growing === true && (launch < 200)){
				arrowHeight += 2;
				launch = launch + refresh;
			} else {
				growing = false;
			}	
		
			arrowOffsetY = arrowHeight / 2;
		}
		
		
		function makeVerts() {
			setTimeout( () => {
				if (fallingVerts.length < maxVerts){
					const vert = document.createElement("div");
					vert.classList.add("fallingVert");
					vertSpawnX = Math.random() * 100;
					vert.style.left = vertSpawnX.toString() + "vw";
					vert.style.top = vertSpawnY.toString() + "vh";
					fallingVerts.push({div : vert, x : vertSpawnX, y : vertSpawnY, velY : 0});
					document.body.append(vert);
				}
			}, refresh * Math.random() * dropInterval);
		}
		
		function updateVerts() {
			let i = 0;
			
			for (const vert of fallingVerts) {
				vert.y += vert.velY;
				vert.div.style.top = vert.y.toString() + "vh";
				
				
				if (vert.y > 100) { 
					fallingVerts.splice(i, 1);
					vert.div.remove();
				} else if ( Math.abs(vert.x - (posX + 49.5)) < 4 && Math.abs(vert.y - (posY + 45)) < 9){
					fallingVerts.splice(i, 1);
					vert.div.remove();
					if (running) {
						health--;
					}
				}
				i++;
			}
		}
		
		
		function updateScore(){
			scoreBox.textContent = Math.trunc(score).toString();
		}
		
		function updateHealth(){
			healthBox.textContent = health.toString();
		}
		
		function updateHighScore(){
			highScoreBox.textContent = Math.trunc(highScore).toString();
		}
		
		function gameLoop(){
			
			
			setTimeout(() => {  	
									vh = window.innerHeight;
									vw = window.innerWidth;
									
									
									tilt = Math.atan((cursorY - posY - 50) / (cursorX - posX - 49.99)) + 1.57;
									
									if(cursorX - posX - 49.99 < 0){
										tilt = 3.14 + tilt;
									}
									
									if (running) {
										gravity();
										updatePlayerPos();
										makeVerts();
										
										score += 0.1;
										
										updateScore();
										updateHealth();
										growArrow();
										updateVerts();
										
										if (dropInterval > 100) {
											dropInterval -= 1;
										}
										
										if (maxVerts < 5000) {
											maxVerts += 0.003;
										}
										
									} else {
										while(fallingVerts.length > 0){
											fallingVerts[0].div.remove();
											fallingVerts.shift();
										}
										restart();
									}

									if (health <= 0 || posX < -55 || posX > 55 || posY < -55 || posY > 55) { growing = false; running = false; }
									
									player.style.left = "calc(50vw - 5vh + " + posX.toString() + "vw";
									player.style.top = "calc(45vh + " + posY.toString() + "vh"; 
									
									arrow.style.height = arrowHeight.toString() + "vh";
									arrow.style.width = arrowWidth.toString() + "vh";
									
									arrow.style.left = "calc(50vw - " + arrowOffsetX.toString() + "vh + " + posX.toString() + "vw";
									arrow.style.top = "calc(50vh - " + arrowOffsetY.toString() + "vh + " + posY.toString() + "vh"; 
									
									arrow.style.transform = "rotate(" + tilt.toString() + "rad)";
									
									if (score > highScore) {
										highScore = score;
										document.cookie = 'highScore=' + highScore;
										updateHighScore();
									}
									
									gameLoop();
									
			}, refresh);
		}
			
		function trackMouse(event) {
			cursorX = (event.clientX / vw) * 100;
			cursorY = (event.clientY / vh) * 100; 
		}
		
		function startGrow() {
			if (launch === 50){
				growing = true;
			} 
		}
		
		function release() {
			velY = ( Math.sin(tilt - 1.57) * (launch / 200) );
			velX = ( Math.cos(tilt - 1.57) * (launch / 200) );
				
			launch = 50;
			arrowHeight = 20;
			arrowWidth = 20;
			
			growing = false;
		}
		
		document.addEventListener('keydown', (event) => {
			let name = event.code;
			
			if (name === "KeyR"){
				running = false;
			}

			if (name == "Space" && launch < 200){
				startGrow();
			}
			
		});
		
		document.addEventListener('keyup', (event) => {
			let name = event.code;
			
			if (name == "Space"){
				release();
			}
			
		});
		
		document.addEventListener('mousedown', (event) => {
			startGrow();
		});
		
		document.addEventListener('mouseup', (event) => {
			release();
		});
		
		document.addEventListener('mousemove', trackMouse);
		
		</script>
		
		<script>
			gameLoop();
		</script>
	</body>
	
</html>
